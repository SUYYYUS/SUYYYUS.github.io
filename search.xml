<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>11.20每日算法</title>
      <link href="/2024/11/20/CodeDisplay/11.20%E7%AE%97%E6%B3%95/"/>
      <url>/2024/11/20/CodeDisplay/11.20%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="701-二叉搜索树中的插入操作"><a href="#701-二叉搜索树中的插入操作" class="headerlink" title="701.二叉搜索树中的插入操作"></a>701.二叉搜索树中的插入操作</h3><ul><li>思路</li></ul><p>在本题中，我们发现当前节点为空的时候，那就证明可以插入一个新节点</p><p>使用递归或者迭代都可以</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">insertIntoBST</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="comment">//如果为0，表明可以创建新节点进行插入</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line">            <span class="keyword">return</span> temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        <span class="keyword">if</span>(val &lt; root.val)&#123;</span><br><span class="line">            root.left = insertIntoBST(root.left, val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(val &gt; root.val)&#123;</span><br><span class="line">            root.right = insertIntoBST(root.right, val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root; <span class="comment">//返回节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>ps：</strong>这题虽然题目说会有不同结构，但是二叉搜索树我们一定是可以把节点插入最后的，直接当作叶子节点插入即可</p><h4 id="力扣"><a href="#力扣" class="headerlink" title="力扣"></a>力扣</h4><ul><li>701</li></ul><h3 id="450-删除二叉搜索树中的节点"><a href="#450-删除二叉搜索树中的节点" class="headerlink" title="450.删除二叉搜索树中的节点"></a>450.删除二叉搜索树中的节点</h3><p><strong>关键：</strong>在删除完一个节点后，可能会有以下几种情况发生</p><ul><li>第一种情况：没找到删除的节点，遍历到空节点直接返回了</li><li>找到删除的节点<ul><li>第二种情况：左右孩子都为空（叶子节点），直接删除节点， 返回NULL为根节点</li><li>第三种情况：删除节点的左孩子为空，右孩子不为空，删除节点，右孩子补位，返回右孩子为根节点</li><li>第四种情况：删除节点的右孩子为空，左孩子不为空，删除节点，左孩子补位，返回左孩子为根节点</li><li>第五种情况：左右孩子节点都不为空，则将删除节点的左子树头结点（左孩子）放到删除节点的右子树的最左面节点的左孩子上，返回删除节点右孩子为新的根节点。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">deleteNode</span><span class="params">(TreeNode root, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">//没有找到目标节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.val == key)&#123;</span><br><span class="line">            <span class="comment">//找到目标节点，分情况讨论</span></span><br><span class="line">            <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">//为叶子节点</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(root.left != <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> root.right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//左右都不为空</span></span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> root.right;</span><br><span class="line">                <span class="keyword">while</span>(temp.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                    temp = temp.left; <span class="comment">//右孩子的最左孩子就是右子树最小的数字</span></span><br><span class="line">                &#125;</span><br><span class="line">                temp.left = root.left; <span class="comment">//把根节点的左子树给它</span></span><br><span class="line">                <span class="keyword">return</span> root.right; <span class="comment">//返回右节点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左右遍历</span></span><br><span class="line">        <span class="keyword">if</span>(key &lt; root.val)&#123;</span><br><span class="line">            root.left = deleteNode(root.left, key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(key &gt; root.val)&#123;</span><br><span class="line">            root.right = deleteNode(root.right, key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="力扣-1"><a href="#力扣-1" class="headerlink" title="力扣"></a>力扣</h4><ul><li>450</li></ul><h3 id="669-修建二叉搜索树"><a href="#669-修建二叉搜索树" class="headerlink" title="669.修建二叉搜索树"></a>669.修建二叉搜索树</h3><p>给定一个二叉搜索树，同时给定最小边界L 和最大边界 R。通过修剪二叉搜索树，使得所有节点的值在[L, R]中 (R&gt;&#x3D;L) 。你可能需要改变树的根节点，所以结果应当返回修剪好的二叉搜索树的新的根节点。</p><p>递归三部曲</p><ul><li>确定递归函数的参数以及返回值</li></ul><p>因为是要遍历整棵树，做修改，其实不需要返回值也可以，我们也可以完成修剪（其实就是从二叉树中移除节点）的操作。</p><p>但是有返回值，更方便，可以通过递归函数的返回值来移除节点。</p><ul><li>确定终止条件</li></ul><p>修剪的操作并不是在终止条件上进行的，所以就是遇到空节点返回就可以了</p><ul><li>确定单层递归的逻辑</li></ul><p>如果root（当前节点）的元素小于low的数值，那么应该递归右子树，并返回右子树符合条件的头结点。</p><p>如果root(当前节点)的元素大于high的，那么应该递归左子树，并返回左子树符合条件的头结点。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">trimBST</span><span class="params">(TreeNode root, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">        <span class="comment">//为空返回空</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.val &lt; low)&#123;</span><br><span class="line">            <span class="comment">//最小了，要向右子树走，右子树不一定都小于low</span></span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> trimBST(root.right, low, high);</span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.val &gt; high)&#123;</span><br><span class="line">            <span class="comment">//同理</span></span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> trimBST(root.left, low, high);</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//数字刚好在中间，向下遍历</span></span><br><span class="line">        root.left = trimBST(root.left, low, high);</span><br><span class="line">        root.right = trimBST(root.right, low, high);</span><br><span class="line">        <span class="comment">//返回节点</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为如果节点值小于low，说明它的left也小，所以遍历完right就直接返回就行了；同理当大于high的也是一样的情况</p><h4 id="力扣-2"><a href="#力扣-2" class="headerlink" title="力扣"></a>力扣</h4><ul><li>669</li></ul><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>这几道题都是通过平衡二叉树的特性，左小右大进行遍历，熟悉该规律，灵活运用</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>11.19每日算法</title>
      <link href="/2024/11/19/CodeDisplay/11.19%E7%AE%97%E6%B3%95/"/>
      <url>/2024/11/19/CodeDisplay/11.19%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="501-二叉树中的众数"><a href="#501-二叉树中的众数" class="headerlink" title="501.二叉树中的众数"></a>501.二叉树中的众数</h3><p>给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。</p><p>首先如果不是二叉搜索树的话，应该怎么解题，是二叉搜索树，又应该如何解题，两种方式做一个比较，可以加深大家对二叉树的理解。</p><ul><li><p>如果是普通二叉树，那就直接全遍历一次，用map收集他们出现的次数，再做后续操作即可</p></li><li><p>二叉搜索树：遍历顺序为中序，因为这样是有序的</p></li></ul><p>使用双指针法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//全局变量</span></span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">//用于存放结果集</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">//pre指针，用于双指针</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">maxCount</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">//记录最大数量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">//用于记录当前数字的数量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] findMode(TreeNode root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//以下是二叉搜索树的方法</span></span><br><span class="line">        traversal(root);</span><br><span class="line">        <span class="keyword">return</span> list.stream().mapToInt(Integer::intValue).toArray();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">traversal</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//中序遍历</span></span><br><span class="line">        <span class="comment">//左</span></span><br><span class="line">        traversal(root.left);</span><br><span class="line">        <span class="comment">//主要核心</span></span><br><span class="line">        <span class="keyword">if</span>(temp == <span class="literal">null</span>)&#123;</span><br><span class="line">            count = <span class="number">1</span>; <span class="comment">//遍历叶子节点</span></span><br><span class="line">        &#125; <span class="comment">//使用else if是为只走其中一种情况</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(temp.val == root.val)&#123;</span><br><span class="line">            count++; <span class="comment">//相同数字加一</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            count = <span class="number">1</span>; <span class="comment">//不相同，重置count</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//temp紧随cur</span></span><br><span class="line">        temp = root;</span><br><span class="line">        <span class="comment">//判断count和maxCount</span></span><br><span class="line">        <span class="keyword">if</span>(count == maxCount)&#123;</span><br><span class="line">            list.add(root.val); <span class="comment">//添加元素</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(count &gt; maxCount)&#123;</span><br><span class="line">            maxCount = count; <span class="comment">//更新max值</span></span><br><span class="line">            list.clear(); <span class="comment">//清空原来的结果集</span></span><br><span class="line">            list.add(root.val); <span class="comment">//更新最新的结果</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//右</span></span><br><span class="line">        traversal(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是对于二叉搜索树可以这样，但是如果不是的话，就不能用</p><h4 id="力扣"><a href="#力扣" class="headerlink" title="力扣"></a>力扣</h4><ul><li>501</li></ul><h3 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236. 二叉树的最近公共祖先"></a>236. 二叉树的最近公共祖先</h3><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p><strong>思路：</strong></p><p>使用回溯自底向上进行查找，使用后序遍历，刚好就是回溯操作(<strong>难点</strong>) ，怎么从下到上是一个难点，大部分思想都是从上向下</p><p><strong>首先最容易想到的一个情况：如果找到一个节点，发现左子树出现结点p，右子树出现节点q，或者 左子树出现结点q，右子树出现节点p，那么该节点就是节点p和q的最近公共祖先。</strong></p><p><strong>但是很多人容易忽略一个情况，就是节点本身p(q)，它拥有一个子孙节点q(p)。</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="comment">//如果是null直接返回null</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果刚好该节点是p或q，直接返回该节点</span></span><br><span class="line">        <span class="keyword">if</span>(root == p || root == q)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//使用后序遍历，回溯从下到上</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        <span class="comment">//如果左右不为空，说明当前节点肯定是公共祖先</span></span><br><span class="line">        <span class="keyword">if</span>(left != <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左空，右不空，返回右</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(left == <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//右空，左不空，返回右</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(left != <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左右都是空，没有在该树上找到指定节点的祖先</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法已经包含了情况2了，只要我们找到了任何一个节点，那就可以直接返回，到最后能够保证一定会找到祖先</p><h4 id="力扣-1"><a href="#力扣-1" class="headerlink" title="力扣"></a>力扣</h4><ul><li>236</li></ul><h3 id="小结四"><a href="#小结四" class="headerlink" title="小结四"></a>小结四</h3><ul><li>二叉树搜索树一般都是使用中序遍历，因为这样的话遍历出来的序列是有序的</li></ul><h3 id="235-二叉搜索树的最近公共祖先"><a href="#235-二叉搜索树的最近公共祖先" class="headerlink" title="235. 二叉搜索树的最近公共祖先"></a>235. 二叉搜索树的最近公共祖先</h3><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p><p><strong>关键：</strong>二叉搜索树是有序的，要好好使用这一特点</p><p>这题无关遍历顺序，从从根节点向下遍历</p><p>因为是有序树，所以 如果 中间节点是 q 和 p 的公共祖先，那么 中节点的数组 一定是在 [p, q]区间的。即 中节点 &gt; p &amp;&amp; 中节点 &lt; q 或者 中节点 &gt; q &amp;&amp; 中节点 &lt; p。</p><p>如果节点值小于两个，那么就向右子树遍历下去，反之就向左子树；但是如果一大一小，那么当前节点就是公共祖先，为什么？</p><p>因为现在已经是一大一小，那么如果你还要往下，必要会错过一个节点，因为一个在左一个在右，但凡走一边，另一边就不能再走了</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//都小，向右子树遍历</span></span><br><span class="line">        <span class="keyword">if</span>(root.val &lt; p.val &amp;&amp; root.val &lt; q.val)&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> lowestCommonAncestor(root.right, p , q);</span><br><span class="line">            <span class="keyword">if</span>(right != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> right; <span class="comment">//说明找到了，直接返回</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//都大，向左子树遍历</span></span><br><span class="line">        <span class="keyword">if</span>(root.val &gt; p.val &amp;&amp; root.val &gt; q.val)&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> lowestCommonAncestor(root.left, p, q);</span><br><span class="line">            <span class="keyword">if</span>(left != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> left; <span class="comment">//说明找到了</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//刚好处于中间，即最近的公共祖先,直接返回</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="力扣-2"><a href="#力扣-2" class="headerlink" title="力扣"></a>力扣</h4><ul><li>235</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>11.18每日算法</title>
      <link href="/2024/11/18/CodeDisplay/11.18%E7%AE%97%E6%B3%95/"/>
      <url>/2024/11/18/CodeDisplay/11.18%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98.验证二叉搜索树"></a>98.验证二叉搜索树</h3><p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p><p>假设一个二叉搜索树具有如下特征：</p><ul><li>节点的左子树只包含小于当前节点的数。</li><li>节点的右子树只包含大于当前节点的数。</li><li>所有左子树和右子树自身必须也是二叉搜索树。</li></ul><p><strong>思路：</strong>要知道中序遍历下，输出的二叉搜索树节点的数值是有序序列。有了这个特性，<strong>验证二叉搜索树，就相当于变成了判断一个序列是不是递增的了。</strong></p><ul><li>另一种更好的方法：不用数组，就用前一个节点和后一个节点进行比较，双指针，类似于数组中的运用</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//使用双指针法</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">left</span> <span class="operator">=</span> isValidBST(root.left); <span class="comment">//左</span></span><br><span class="line">        <span class="keyword">if</span>(temp != <span class="literal">null</span> &amp;&amp; temp.val &gt;= root.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            temp = root;</span><br><span class="line">        &#125; <span class="comment">//中</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">right</span> <span class="operator">=</span> isValidBST(root.right); <span class="comment">//右</span></span><br><span class="line">        <span class="keyword">return</span> (left &amp;&amp; right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="力扣"><a href="#力扣" class="headerlink" title="力扣"></a>力扣</h4><ul><li>98</li></ul><h3 id="二叉搜索树的最小绝对差"><a href="#二叉搜索树的最小绝对差" class="headerlink" title="二叉搜索树的最小绝对差"></a>二叉搜索树的最小绝对差</h3><p>给你一棵所有节点为非负值的二叉搜索树，请你计算树中任意两节点的差的绝对值的最小值。</p><ul><li><p>第一种暴力算法：先中序遍历转化为一个数组，然后相邻元素找</p></li><li><p>第二种双指针</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMinimumDifference</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;    </span><br><span class="line">        get(root);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">get</span><span class="params">(TreeNode cur)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        get(cur.left);</span><br><span class="line">        <span class="keyword">if</span>(temp != <span class="literal">null</span>)&#123;</span><br><span class="line">            result = result &lt; (cur.val - temp.val) ? result : (cur.val - temp.val);</span><br><span class="line">        &#125;</span><br><span class="line">        temp = cur;</span><br><span class="line">        get(cur.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="力扣-1"><a href="#力扣-1" class="headerlink" title="力扣"></a>力扣</h4><ul><li>530</li></ul><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>这两个题都是使用双指针，比起暴力的数组方式要好一点，熟悉掌握双指针、全局变量的运用。同时，中序遍历是出来的是有序序列</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>11.15每日算法</title>
      <link href="/2024/11/15/CodeDisplay/11.15%E7%AE%97%E6%B3%95/"/>
      <url>/2024/11/15/CodeDisplay/11.15%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="小结三"><a href="#小结三" class="headerlink" title="小结三"></a>小结三</h3><p>一般情况下：<strong>如果需要搜索整棵二叉树，那么递归函数就不要返回值，如果要搜索其中一条符合条件的路径，递归函数就需要返回值，因为遇到符合条件的路径了就要及时返回。</strong></p><p><strong>注意类似用数组构造二叉树的题目，每次分隔尽量不要定义新的数组，而是通过下标索引直接在原数组上操作，这样可以节约时间和空间上的开销。</strong></p><h3 id="617-合并二叉树"><a href="#617-合并二叉树" class="headerlink" title="617.合并二叉树"></a>617.合并二叉树</h3><p>题目描述：</p><p>给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。</p><p>你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。</p><p>注意: 合并必须从两个树的根节点开始。</p><ul><li>步骤：同时操作两个二叉树即可</li></ul><p>终止条件：如果一个树为空另一个不是，就直接返回另一个树（并且其实已经包含了两个树为空的情况，反正是返回null）</p><p>不用重新创建一个树，直接在一个树上进行相加操作</p><p>遍历顺序三种都可以，不影响</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">mergeTrees</span><span class="params">(TreeNode root1, TreeNode root2)</span> &#123;</span><br><span class="line">        <span class="comment">//终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(root1 == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root2 == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//进行合并，使用的是先序遍历</span></span><br><span class="line">        root1.val = root1.val + root2.val;</span><br><span class="line">        root1.left = mergeTrees(root1.left, root2.left);</span><br><span class="line">        root1.right = mergeTrees(root1.right, root2.right);</span><br><span class="line">        <span class="comment">//返回结果</span></span><br><span class="line">        <span class="keyword">return</span> root1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="力扣"><a href="#力扣" class="headerlink" title="力扣"></a>力扣</h4><ul><li>617</li></ul><h3 id="700-二叉搜索树中的搜索"><a href="#700-二叉搜索树中的搜索" class="headerlink" title="700.二叉搜索树中的搜索"></a>700.二叉搜索树中的搜索</h3><p>二叉搜索树是一个有序树：</p><ul><li>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li><li>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li><li>它的左、右子树也分别为二叉搜索树</li></ul><p>比较简单这道题</p><p>迭代法的话可以说没必要，因为二叉搜索树的特性已经帮我们确定好了查找路径</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">searchBST</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span> || root.val == val)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">res</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(val &gt; root.val)&#123;</span><br><span class="line">            res = searchBST(root.right, val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(val &lt; root.val)&#123;</span><br><span class="line">            res = searchBST(root.left, val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>ps：</strong>今天两个题目都比较简单，就当作是保持每天都在写两道题吧</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>11.14每日算法</title>
      <link href="/2024/11/14/CodeDisplay/11.14%E7%AE%97%E6%B3%95/"/>
      <url>/2024/11/14/CodeDisplay/11.14%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="654-最大二叉树"><a href="#654-最大二叉树" class="headerlink" title="654.最大二叉树"></a>654.最大二叉树</h3><p>给定一个不含重复元素的整数数组。一个以此数组构建的最大二叉树定义如下：</p><ul><li>二叉树的根是数组中的最大元素。</li><li>左子树是通过数组中最大值左边部分构造出的最大二叉树。</li><li>右子树是通过数组中最大值右边部分构造出的最大二叉树。</li></ul><p>一般使用前序遍历（中左右），从根节点开始从上向下遍历</p><ul><li><p>步骤：</p><p>如果数组长度为1，证明这就是一个叶子节点，直接创建一个节点返回</p><p>找到最大值，创建节点，开始左右遍历</p><p>进行数组分割，保证左子树的数组的话，传入的数组长度一定要大于等于1，即最大值的下标大于0；保证右子树的就要确保index不是当前数组的最后一个，也就是length - 1</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">constructMaximumBinaryTree</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> constrcutTree(nums, <span class="number">0</span> , nums.length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">constrcutTree</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> left, <span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="comment">//终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(left &gt;= right)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//数组中只有一个节点，那就是叶子节点</span></span><br><span class="line">        <span class="keyword">if</span>(left == right - <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(nums[left]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left; i &lt; right ; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; max)&#123;</span><br><span class="line">                max = nums[i];</span><br><span class="line">                index = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(max);</span><br><span class="line">        <span class="comment">//左右递归</span></span><br><span class="line">        <span class="comment">//左闭右开原则</span></span><br><span class="line">        root.left = constrcutTree(nums, left, index);</span><br><span class="line">        root.right = constrcutTree(nums, index + <span class="number">1</span>, right);</span><br><span class="line">        <span class="comment">//返回二叉树</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="新学的知识"><a href="#新学的知识" class="headerlink" title="新学的知识"></a>新学的知识</h4><p>如何是要递归使用一个数组，可以通过分配索引，从而减少新建数组的消耗</p><h4 id="力扣"><a href="#力扣" class="headerlink" title="力扣"></a>力扣</h4><ul><li>654</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>11.13每日算法</title>
      <link href="/2024/11/13/CodeDisplay/11.13%E7%AE%97%E6%B3%95/"/>
      <url>/2024/11/13/CodeDisplay/11.13%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="106-从中序与后序遍历序列构造二叉树"><a href="#106-从中序与后序遍历序列构造二叉树" class="headerlink" title="106.从中序与后序遍历序列构造二叉树"></a>106.从中序与后序遍历序列构造二叉树</h3><ul><li>关键点：以后序数组最后一个元素为节点，在中序数组中进行切割</li></ul><p><strong>后序是左右中，中序是中左右</strong></p><p>步骤：</p><ol><li>后序数组为0，空节点</li><li>后序数组最后一个元素为节点元素</li><li>寻找中序数组的位置作为切割点</li><li>切中序数组</li><li>切后序数组</li><li>递归处理左区间后区间</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] inorder, <span class="type">int</span>[] postorder)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(postorder.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> postorder[postorder.length -<span class="number">1</span>];</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(temp);</span><br><span class="line">        <span class="keyword">if</span>(postorder.length == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历中序数组寻找切割点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> indexOf(inorder, temp);</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftSize</span> <span class="operator">=</span> index; <span class="comment">//左子树的长度大小</span></span><br><span class="line">        <span class="comment">//开始切割中序和后序数组</span></span><br><span class="line">        <span class="comment">//使用函数复制新数组</span></span><br><span class="line">        <span class="comment">//中序切割</span></span><br><span class="line">        <span class="type">int</span> leftInorder[] = Arrays.copyOfRange(inorder, <span class="number">0</span>, index); <span class="comment">//左闭右开</span></span><br><span class="line">        <span class="type">int</span> rightInorder[] = Arrays.copyOfRange(inorder, index + <span class="number">1</span>, inorder.length);</span><br><span class="line">        <span class="comment">//后序切割</span></span><br><span class="line">        <span class="type">int</span> leftPostorder[] = Arrays.copyOfRange(postorder, <span class="number">0</span>, index);</span><br><span class="line">        <span class="type">int</span> rightPostorder[] = Arrays.copyOfRange(postorder, index, postorder.length - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//返回二叉树</span></span><br><span class="line">        root.left = buildTree(leftInorder, leftPostorder);</span><br><span class="line">        root.right = buildTree(rightInorder, rightPostorder);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; ; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] == x) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>关键：</strong>知道如何切割数组</p><h4 id="新学习的东西"><a href="#新学习的东西" class="headerlink" title="新学习的东西"></a>新学习的东西</h4><p>Arrays.copyOfRange(目标数组, 起始下标, 终止下标);</p><p>这是一个方便从一个数组复制元素到一个新的数组上，注意该方法是<strong>左闭右开</strong></p><h4 id="力扣"><a href="#力扣" class="headerlink" title="力扣"></a>力扣</h4><ul><li>106</li><li>105.前序和中序遍历序列构造二叉树</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(preorder.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> preorder[<span class="number">0</span>];</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(temp);</span><br><span class="line">        <span class="keyword">if</span>(preorder.length == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左子树的长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">leftSize</span> <span class="operator">=</span> indexOf(inorder, temp);</span><br><span class="line">        <span class="comment">//开始切割</span></span><br><span class="line">        <span class="comment">//中序数组</span></span><br><span class="line">        <span class="type">int</span>[] leftInOrder = Arrays.copyOfRange(inorder, <span class="number">0</span> , leftSize);</span><br><span class="line">        <span class="type">int</span>[] rightInOrder = Arrays.copyOfRange(inorder, leftSize+<span class="number">1</span>, inorder.length);</span><br><span class="line">        <span class="comment">//前序数组</span></span><br><span class="line">        <span class="type">int</span>[] leftPreOrder = Arrays.copyOfRange(preorder, <span class="number">1</span> , leftSize + <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span>[] rightPreOrder = Arrays.copyOfRange(preorder, leftSize + <span class="number">1</span>, preorder.length);</span><br><span class="line">        <span class="comment">//递归</span></span><br><span class="line">        root.left =  buildTree(leftPreOrder, leftInOrder);</span><br><span class="line">        root.right = buildTree(rightPreOrder, rightInOrder);</span><br><span class="line">        <span class="comment">//返回二叉树</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> goal)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length; i ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i] == goal)&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>11.12每日算法</title>
      <link href="/2024/11/12/CodeDisplay/11.12%E7%AE%97%E6%B3%95/"/>
      <url>/2024/11/12/CodeDisplay/11.12%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="112-路径总和"><a href="#112-路径总和" class="headerlink" title="112.路径总和"></a>112.路径总和</h3><p>给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。</p><ul><li><p>可以反过来想，传入目标值，遇到一个节点，就让目标值减去该节点，如果遇到叶子节点并且减后为0，则找到路径</p></li><li><p>终止条件：叶子节点且刚好为0，或者叶子节点但是不为0</p></li><li><p>递归：返回值是告诉我们是否有符合题目的路径，所以当左遍历是true的时候，说明符合要求，就要立即返回</p></li></ul><p><strong>回溯本身就是加加减减</strong></p><ul><li>递归法</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasPathSum</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isSuit(root, targetSum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSuit</span><span class="params">(TreeNode root, <span class="type">int</span> num)</span>&#123;</span><br><span class="line">        <span class="comment">//终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span> &amp;&amp; num-root.val == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span> &amp;&amp; num-root.val != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//递归同时回溯</span></span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="literal">null</span>)&#123;</span><br><span class="line">            num = num - root.val;</span><br><span class="line">            <span class="keyword">if</span>(isSuit(root.left, num)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            num = num + root.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.right != <span class="literal">null</span>)&#123;</span><br><span class="line">            num = num - root.val;</span><br><span class="line">            <span class="keyword">if</span>(isSuit(root.right, num)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            num = num + root.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="力扣"><a href="#力扣" class="headerlink" title="力扣"></a>力扣</h4><ul><li>113</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">pathSum</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        hasPath(root, targetSum, res, list);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hasPath</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum, List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; list)</span>&#123;</span><br><span class="line">        list.add(root.val);</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span> &amp;&amp; targetSum-root.val == <span class="number">0</span>)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(list)); <span class="comment">// 为了确保每个路径的独立性，你需要在将路径添加到 res 时创建一个新的 ArrayList 副本。这样，即使后续对 list 进行修改，也不会影响到已经添加到 res 中的路径。</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span> &amp;&amp; targetSum-root.val != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="literal">null</span>)&#123;</span><br><span class="line">            targetSum = targetSum - root.val;</span><br><span class="line">            hasPath(root.left, targetSum, res, list);</span><br><span class="line">            targetSum = targetSum + root.val;</span><br><span class="line">            list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.right != <span class="literal">null</span>)&#123;</span><br><span class="line">            targetSum = targetSum - root.val;</span><br><span class="line">            hasPath(root.right, targetSum, res, list);</span><br><span class="line">            targetSum = targetSum + root.val;</span><br><span class="line">            list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释为什么要new ArrayList&lt;&gt;()：</strong></p><p>在递归过程中，<code>list</code> 是一个共享的变量，用于存储当前路径上的节点值。当你直接将 <code>list</code> 添加到 <code>res</code> 中时，实际上添加的是 <code>list</code> 的引用，而不是 <code>list</code> 的副本。这意味着后续对 <code>list</code> 的修改（例如在递归返回时移除元素）会影响到已经添加到 <code>res</code> 中的路径。</p><p>为了确保每个路径的独立性，你需要在将路径添加到 <code>res</code> 时创建一个新的 <code>ArrayList</code> 副本。这样，即使后续对 <code>list</code> 进行修改，也不会影响到已经添加到 <code>res</code> 中的路径。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>第一个文章</title>
      <link href="/2024/11/10/%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%96%87%E7%AB%A0/"/>
      <url>/2024/11/10/%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><p>我</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2024/11/10/hello-world/"/>
      <url>/2024/11/10/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
