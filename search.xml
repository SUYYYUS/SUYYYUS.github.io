<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>11.18每日算法</title>
      <link href="/2024/11/18/CodeDisplay/11.18%E7%AE%97%E6%B3%95/"/>
      <url>/2024/11/18/CodeDisplay/11.18%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98.验证二叉搜索树"></a>98.验证二叉搜索树</h3><p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p><p>假设一个二叉搜索树具有如下特征：</p><ul><li>节点的左子树只包含小于当前节点的数。</li><li>节点的右子树只包含大于当前节点的数。</li><li>所有左子树和右子树自身必须也是二叉搜索树。</li></ul><p><strong>思路：</strong>要知道中序遍历下，输出的二叉搜索树节点的数值是有序序列。有了这个特性，<strong>验证二叉搜索树，就相当于变成了判断一个序列是不是递增的了。</strong></p><ul><li>另一种更好的方法：不用数组，就用前一个节点和后一个节点进行比较，双指针，类似于数组中的运用</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//使用双指针法</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">left</span> <span class="operator">=</span> isValidBST(root.left); <span class="comment">//左</span></span><br><span class="line">        <span class="keyword">if</span>(temp != <span class="literal">null</span> &amp;&amp; temp.val &gt;= root.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            temp = root;</span><br><span class="line">        &#125; <span class="comment">//中</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">right</span> <span class="operator">=</span> isValidBST(root.right); <span class="comment">//右</span></span><br><span class="line">        <span class="keyword">return</span> (left &amp;&amp; right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="力扣"><a href="#力扣" class="headerlink" title="力扣"></a>力扣</h4><ul><li>98</li></ul><h3 id="二叉搜索树的最小绝对差"><a href="#二叉搜索树的最小绝对差" class="headerlink" title="二叉搜索树的最小绝对差"></a>二叉搜索树的最小绝对差</h3><p>给你一棵所有节点为非负值的二叉搜索树，请你计算树中任意两节点的差的绝对值的最小值。</p><ul><li><p>第一种暴力算法：先中序遍历转化为一个数组，然后相邻元素找</p></li><li><p>第二种双指针</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMinimumDifference</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;    </span><br><span class="line">        get(root);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">get</span><span class="params">(TreeNode cur)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        get(cur.left);</span><br><span class="line">        <span class="keyword">if</span>(temp != <span class="literal">null</span>)&#123;</span><br><span class="line">            result = result &lt; (cur.val - temp.val) ? result : (cur.val - temp.val);</span><br><span class="line">        &#125;</span><br><span class="line">        temp = cur;</span><br><span class="line">        get(cur.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="力扣-1"><a href="#力扣-1" class="headerlink" title="力扣"></a>力扣</h4><ul><li>530</li></ul><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>这两个题都是使用双指针，比起暴力的数组方式要好一点，熟悉掌握双指针、全局变量的运用。同时，中序遍历是出来的是有序序列</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>11.15每日算法</title>
      <link href="/2024/11/15/CodeDisplay/11.15%E7%AE%97%E6%B3%95/"/>
      <url>/2024/11/15/CodeDisplay/11.15%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="小结三"><a href="#小结三" class="headerlink" title="小结三"></a>小结三</h3><p>一般情况下：<strong>如果需要搜索整棵二叉树，那么递归函数就不要返回值，如果要搜索其中一条符合条件的路径，递归函数就需要返回值，因为遇到符合条件的路径了就要及时返回。</strong></p><p><strong>注意类似用数组构造二叉树的题目，每次分隔尽量不要定义新的数组，而是通过下标索引直接在原数组上操作，这样可以节约时间和空间上的开销。</strong></p><h3 id="617-合并二叉树"><a href="#617-合并二叉树" class="headerlink" title="617.合并二叉树"></a>617.合并二叉树</h3><p>题目描述：</p><p>给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。</p><p>你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。</p><p>注意: 合并必须从两个树的根节点开始。</p><ul><li>步骤：同时操作两个二叉树即可</li></ul><p>终止条件：如果一个树为空另一个不是，就直接返回另一个树（并且其实已经包含了两个树为空的情况，反正是返回null）</p><p>不用重新创建一个树，直接在一个树上进行相加操作</p><p>遍历顺序三种都可以，不影响</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">mergeTrees</span><span class="params">(TreeNode root1, TreeNode root2)</span> &#123;</span><br><span class="line">        <span class="comment">//终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(root1 == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root2 == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//进行合并，使用的是先序遍历</span></span><br><span class="line">        root1.val = root1.val + root2.val;</span><br><span class="line">        root1.left = mergeTrees(root1.left, root2.left);</span><br><span class="line">        root1.right = mergeTrees(root1.right, root2.right);</span><br><span class="line">        <span class="comment">//返回结果</span></span><br><span class="line">        <span class="keyword">return</span> root1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="力扣"><a href="#力扣" class="headerlink" title="力扣"></a>力扣</h4><ul><li>617</li></ul><h3 id="700-二叉搜索树中的搜索"><a href="#700-二叉搜索树中的搜索" class="headerlink" title="700.二叉搜索树中的搜索"></a>700.二叉搜索树中的搜索</h3><p>二叉搜索树是一个有序树：</p><ul><li>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li><li>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li><li>它的左、右子树也分别为二叉搜索树</li></ul><p>比较简单这道题</p><p>迭代法的话可以说没必要，因为二叉搜索树的特性已经帮我们确定好了查找路径</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">searchBST</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span> || root.val == val)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">res</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(val &gt; root.val)&#123;</span><br><span class="line">            res = searchBST(root.right, val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(val &lt; root.val)&#123;</span><br><span class="line">            res = searchBST(root.left, val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>ps：</strong>今天两个题目都比较简单，就当作是保持每天都在写两道题吧</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>11.14每日算法</title>
      <link href="/2024/11/14/CodeDisplay/11.14%E7%AE%97%E6%B3%95/"/>
      <url>/2024/11/14/CodeDisplay/11.14%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="654-最大二叉树"><a href="#654-最大二叉树" class="headerlink" title="654.最大二叉树"></a>654.最大二叉树</h3><p>给定一个不含重复元素的整数数组。一个以此数组构建的最大二叉树定义如下：</p><ul><li>二叉树的根是数组中的最大元素。</li><li>左子树是通过数组中最大值左边部分构造出的最大二叉树。</li><li>右子树是通过数组中最大值右边部分构造出的最大二叉树。</li></ul><p>一般使用前序遍历（中左右），从根节点开始从上向下遍历</p><ul><li><p>步骤：</p><p>如果数组长度为1，证明这就是一个叶子节点，直接创建一个节点返回</p><p>找到最大值，创建节点，开始左右遍历</p><p>进行数组分割，保证左子树的数组的话，传入的数组长度一定要大于等于1，即最大值的下标大于0；保证右子树的就要确保index不是当前数组的最后一个，也就是length - 1</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">constructMaximumBinaryTree</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> constrcutTree(nums, <span class="number">0</span> , nums.length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">constrcutTree</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> left, <span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="comment">//终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(left &gt;= right)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//数组中只有一个节点，那就是叶子节点</span></span><br><span class="line">        <span class="keyword">if</span>(left == right - <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(nums[left]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left; i &lt; right ; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; max)&#123;</span><br><span class="line">                max = nums[i];</span><br><span class="line">                index = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(max);</span><br><span class="line">        <span class="comment">//左右递归</span></span><br><span class="line">        <span class="comment">//左闭右开原则</span></span><br><span class="line">        root.left = constrcutTree(nums, left, index);</span><br><span class="line">        root.right = constrcutTree(nums, index + <span class="number">1</span>, right);</span><br><span class="line">        <span class="comment">//返回二叉树</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="新学的知识"><a href="#新学的知识" class="headerlink" title="新学的知识"></a>新学的知识</h4><p>如何是要递归使用一个数组，可以通过分配索引，从而减少新建数组的消耗</p><h4 id="力扣"><a href="#力扣" class="headerlink" title="力扣"></a>力扣</h4><ul><li>654</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>11.13每日算法</title>
      <link href="/2024/11/13/CodeDisplay/11.13%E7%AE%97%E6%B3%95/"/>
      <url>/2024/11/13/CodeDisplay/11.13%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="106-从中序与后序遍历序列构造二叉树"><a href="#106-从中序与后序遍历序列构造二叉树" class="headerlink" title="106.从中序与后序遍历序列构造二叉树"></a>106.从中序与后序遍历序列构造二叉树</h3><ul><li>关键点：以后序数组最后一个元素为节点，在中序数组中进行切割</li></ul><p><strong>后序是左右中，中序是中左右</strong></p><p>步骤：</p><ol><li>后序数组为0，空节点</li><li>后序数组最后一个元素为节点元素</li><li>寻找中序数组的位置作为切割点</li><li>切中序数组</li><li>切后序数组</li><li>递归处理左区间后区间</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] inorder, <span class="type">int</span>[] postorder)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(postorder.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> postorder[postorder.length -<span class="number">1</span>];</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(temp);</span><br><span class="line">        <span class="keyword">if</span>(postorder.length == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历中序数组寻找切割点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> indexOf(inorder, temp);</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftSize</span> <span class="operator">=</span> index; <span class="comment">//左子树的长度大小</span></span><br><span class="line">        <span class="comment">//开始切割中序和后序数组</span></span><br><span class="line">        <span class="comment">//使用函数复制新数组</span></span><br><span class="line">        <span class="comment">//中序切割</span></span><br><span class="line">        <span class="type">int</span> leftInorder[] = Arrays.copyOfRange(inorder, <span class="number">0</span>, index); <span class="comment">//左闭右开</span></span><br><span class="line">        <span class="type">int</span> rightInorder[] = Arrays.copyOfRange(inorder, index + <span class="number">1</span>, inorder.length);</span><br><span class="line">        <span class="comment">//后序切割</span></span><br><span class="line">        <span class="type">int</span> leftPostorder[] = Arrays.copyOfRange(postorder, <span class="number">0</span>, index);</span><br><span class="line">        <span class="type">int</span> rightPostorder[] = Arrays.copyOfRange(postorder, index, postorder.length - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//返回二叉树</span></span><br><span class="line">        root.left = buildTree(leftInorder, leftPostorder);</span><br><span class="line">        root.right = buildTree(rightInorder, rightPostorder);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; ; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] == x) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>关键：</strong>知道如何切割数组</p><h4 id="新学习的东西"><a href="#新学习的东西" class="headerlink" title="新学习的东西"></a>新学习的东西</h4><p>Arrays.copyOfRange(目标数组, 起始下标, 终止下标);</p><p>这是一个方便从一个数组复制元素到一个新的数组上，注意该方法是<strong>左闭右开</strong></p><h4 id="力扣"><a href="#力扣" class="headerlink" title="力扣"></a>力扣</h4><ul><li>106</li><li>105.前序和中序遍历序列构造二叉树</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(preorder.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> preorder[<span class="number">0</span>];</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(temp);</span><br><span class="line">        <span class="keyword">if</span>(preorder.length == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左子树的长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">leftSize</span> <span class="operator">=</span> indexOf(inorder, temp);</span><br><span class="line">        <span class="comment">//开始切割</span></span><br><span class="line">        <span class="comment">//中序数组</span></span><br><span class="line">        <span class="type">int</span>[] leftInOrder = Arrays.copyOfRange(inorder, <span class="number">0</span> , leftSize);</span><br><span class="line">        <span class="type">int</span>[] rightInOrder = Arrays.copyOfRange(inorder, leftSize+<span class="number">1</span>, inorder.length);</span><br><span class="line">        <span class="comment">//前序数组</span></span><br><span class="line">        <span class="type">int</span>[] leftPreOrder = Arrays.copyOfRange(preorder, <span class="number">1</span> , leftSize + <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span>[] rightPreOrder = Arrays.copyOfRange(preorder, leftSize + <span class="number">1</span>, preorder.length);</span><br><span class="line">        <span class="comment">//递归</span></span><br><span class="line">        root.left =  buildTree(leftPreOrder, leftInOrder);</span><br><span class="line">        root.right = buildTree(rightPreOrder, rightInOrder);</span><br><span class="line">        <span class="comment">//返回二叉树</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> goal)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length; i ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i] == goal)&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>11.12每日算法</title>
      <link href="/2024/11/12/CodeDisplay/11.12%E7%AE%97%E6%B3%95/"/>
      <url>/2024/11/12/CodeDisplay/11.12%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="112-路径总和"><a href="#112-路径总和" class="headerlink" title="112.路径总和"></a>112.路径总和</h3><p>给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。</p><ul><li><p>可以反过来想，传入目标值，遇到一个节点，就让目标值减去该节点，如果遇到叶子节点并且减后为0，则找到路径</p></li><li><p>终止条件：叶子节点且刚好为0，或者叶子节点但是不为0</p></li><li><p>递归：返回值是告诉我们是否有符合题目的路径，所以当左遍历是true的时候，说明符合要求，就要立即返回</p></li></ul><p><strong>回溯本身就是加加减减</strong></p><ul><li>递归法</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasPathSum</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isSuit(root, targetSum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSuit</span><span class="params">(TreeNode root, <span class="type">int</span> num)</span>&#123;</span><br><span class="line">        <span class="comment">//终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span> &amp;&amp; num-root.val == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span> &amp;&amp; num-root.val != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//递归同时回溯</span></span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="literal">null</span>)&#123;</span><br><span class="line">            num = num - root.val;</span><br><span class="line">            <span class="keyword">if</span>(isSuit(root.left, num)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            num = num + root.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.right != <span class="literal">null</span>)&#123;</span><br><span class="line">            num = num - root.val;</span><br><span class="line">            <span class="keyword">if</span>(isSuit(root.right, num)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            num = num + root.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="力扣"><a href="#力扣" class="headerlink" title="力扣"></a>力扣</h4><ul><li>113</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">pathSum</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        hasPath(root, targetSum, res, list);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hasPath</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum, List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; list)</span>&#123;</span><br><span class="line">        list.add(root.val);</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span> &amp;&amp; targetSum-root.val == <span class="number">0</span>)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(list)); <span class="comment">// 为了确保每个路径的独立性，你需要在将路径添加到 res 时创建一个新的 ArrayList 副本。这样，即使后续对 list 进行修改，也不会影响到已经添加到 res 中的路径。</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span> &amp;&amp; targetSum-root.val != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="literal">null</span>)&#123;</span><br><span class="line">            targetSum = targetSum - root.val;</span><br><span class="line">            hasPath(root.left, targetSum, res, list);</span><br><span class="line">            targetSum = targetSum + root.val;</span><br><span class="line">            list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.right != <span class="literal">null</span>)&#123;</span><br><span class="line">            targetSum = targetSum - root.val;</span><br><span class="line">            hasPath(root.right, targetSum, res, list);</span><br><span class="line">            targetSum = targetSum + root.val;</span><br><span class="line">            list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释为什么要new ArrayList&lt;&gt;()：</strong></p><p>在递归过程中，<code>list</code> 是一个共享的变量，用于存储当前路径上的节点值。当你直接将 <code>list</code> 添加到 <code>res</code> 中时，实际上添加的是 <code>list</code> 的引用，而不是 <code>list</code> 的副本。这意味着后续对 <code>list</code> 的修改（例如在递归返回时移除元素）会影响到已经添加到 <code>res</code> 中的路径。</p><p>为了确保每个路径的独立性，你需要在将路径添加到 <code>res</code> 时创建一个新的 <code>ArrayList</code> 副本。这样，即使后续对 <code>list</code> 进行修改，也不会影响到已经添加到 <code>res</code> 中的路径。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>第一个文章</title>
      <link href="/2024/11/10/%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%96%87%E7%AB%A0/"/>
      <url>/2024/11/10/%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><p>我</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2024/11/10/hello-world/"/>
      <url>/2024/11/10/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
